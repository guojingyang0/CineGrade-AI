import { ColorAnalysis, LutFormat } from '../types';

// Helper to clamp values between 0 and 1
const clamp = (val: number) => Math.max(0, Math.min(1, val));

/**
 * Core Color Grading Math
 * Applies the analysis parameters to a single RGB pixel.
 * Inputs and Outputs are in 0-1 range.
 */
export const calculateColorGrade = (r: number, g: number, b: number, analysis: ColorAnalysis): [number, number, number] => {
  let R = r;
  let G = g;
  let B = b;

  // 1. Contrast
  if (analysis.contrast !== 0) {
    const factor = (1.015 * (analysis.contrast + 1.0)) / (1.0 * (1.015 - analysis.contrast));
    R = factor * (R - 0.5) + 0.5;
    G = factor * (G - 0.5) + 0.5;
    B = factor * (B - 0.5) + 0.5;
  }

  // 2. Saturation (Simple luminance-preserving approx)
  if (analysis.saturation !== 1) {
    const lum = 0.2126 * R + 0.7152 * G + 0.0722 * B;
    R = lum + (R - lum) * analysis.saturation;
    G = lum + (G - lum) * analysis.saturation;
    B = lum + (B - lum) * analysis.saturation;
  }

  // 3. Temperature (Blue/Amber axis)
  if (analysis.temperature !== 0) {
    R += analysis.temperature * 0.1;
    B -= analysis.temperature * 0.1;
  }

  // 4. Tint (Green/Magenta axis)
  if (analysis.tint !== 0) {
    G -= analysis.tint * 0.1;
  }

  // 5. Split Toning (Shadows/Highlights)
  const luminance = 0.2126 * R + 0.7152 * G + 0.0722 * B;
  
  // Apply Shadow tint (mostly affects low luminance)
  const shadowStrength = Math.max(0, 1 - luminance * 2) * 0.2;
  R += (analysis.shadowsColor[0] - 0.5) * shadowStrength;
  G += (analysis.shadowsColor[1] - 0.5) * shadowStrength;
  B += (analysis.shadowsColor[2] - 0.5) * shadowStrength;

  // Apply Highlight tint (mostly affects high luminance)
  const highlightStrength = Math.max(0, (luminance - 0.5) * 2) * 0.2;
  R += (analysis.highlightsColor[0] - 0.5) * highlightStrength;
  G += (analysis.highlightsColor[1] - 0.5) * highlightStrength;
  B += (analysis.highlightsColor[2] - 0.5) * highlightStrength;

  return [clamp(R), clamp(G), clamp(B)];
};

// Generate a .cube file string based on analysis parameters
export const generateCubeFile = (analysis: ColorAnalysis, title: string, size: number = 33): string => {
  let content = `# Generated by CineGrade AI\n# Title: ${title}\n# Description: ${analysis.description}\n`;
  content += `LUT_3D_SIZE ${size}\n\n`;

  const step = 1.0 / (size - 1);

  for (let b = 0; b < size; b++) {
    for (let g = 0; g < size; g++) {
      for (let r = 0; r < size; r++) {
        // Normalized RGB (0-1) - Identity
        const inR = r * step;
        const inG = g * step;
        const inB = b * step;

        const [outR, outG, outB] = calculateColorGrade(inR, inG, inB, analysis);

        content += `${outR.toFixed(6)} ${outG.toFixed(6)} ${outB.toFixed(6)}\n`;
      }
    }
  }

  return content;
};

// Generate a HaldCLUT PNG Data URL
export const generateHaldClut = (analysis: ColorAnalysis): string => {
  // Standard Level 8 HaldCLUT (512x512 pixels), represents 64^3 LUT
  const cubeSize = 64;
  const imageSize = 512;
  
  const canvas = document.createElement('canvas');
  canvas.width = imageSize;
  canvas.height = imageSize;
  const ctx = canvas.getContext('2d');
  
  if (!ctx) return '';

  const imgData = ctx.createImageData(imageSize, imageSize);
  const data = imgData.data;

  for (let y = 0; y < imageSize; y++) {
    for (let x = 0; x < imageSize; x++) {
      const totalIndex = y * imageSize + x;
      
      const rIndex = totalIndex % cubeSize;
      const gIndex = Math.floor(totalIndex / cubeSize) % cubeSize;
      const bIndex = Math.floor(totalIndex / (cubeSize * cubeSize)); // 0..63
      
      const inR = rIndex / (cubeSize - 1);
      const inG = gIndex / (cubeSize - 1);
      const inB = bIndex / (cubeSize - 1);

      // Apply Grading
      const [outR, outG, outB] = calculateColorGrade(inR, inG, inB, analysis);

      // Set Pixel Data
      const pixelIndex = totalIndex * 4;
      data[pixelIndex] = Math.round(outR * 255);
      data[pixelIndex + 1] = Math.round(outG * 255);
      data[pixelIndex + 2] = Math.round(outB * 255);
      data[pixelIndex + 3] = 255; // Alpha
    }
  }

  ctx.putImageData(imgData, 0, 0);
  return canvas.toDataURL('image/png');
};

export const downloadLut = (content: string, filename: string) => {
  const a = document.createElement('a');
  
  if (content.startsWith('data:')) {
    a.href = content;
  } else {
    const blob = new Blob([content], { type: 'text/plain' });
    a.href = URL.createObjectURL(blob);
  }
  
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  
  if (!content.startsWith('data:')) {
    URL.revokeObjectURL(a.href);
  }
};